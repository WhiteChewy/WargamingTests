#Тестовое задание 3

---
В рамках 3 тестового задания надо было реализовать функцию сортировки которая отсортирует заданный массив быстрее всего.
 При этом массив может быть абсолютно любого размера и как отсортированным так и не отсортированным.

В рамках данного задания мною были реализованны 2 алгоритма сортировки: __*сортировка подсчетом*__ и 
__*пирамидальная сортировка*__. А так же для сравнение добавлены реализации этих же алгоритмов из старых проектов на C++

Для эталона был выбран алгоритм сортировки __*timsort*__, который в Python используется в качестве алгоритма метода sort()

###Сортировка подсчетом

Исходный код сортировки подсчетом содержится в файле **counting_sort.py**.

Некоторая информация об алгоритме сортировки подсчетом:
1. Устойчевый алгоритм сортировки (т.к. мы по факту пересобираем массив)
2. Лучшая верменная сложность - Ω(n+k), где k - разница между max и min элементом
3. Средняя временная сложность - Θ(n+k), где k - разница между max и min элементом
4. Худшая временная сложность - O(n+k), где k - разница между max и min элементом
5. Количество применяемой памяти - O(k), где k - разница между max и min элементом
6. Сильно зависима от *k* 

###Пирамидальная сортировка

Исходный код сортировки подсчетом содержится в файле **heap_sort.py**

Некоторая информация об алгоритме пирамидальной сортировки:
1. Неустойчивый алгоритм сортировки (т.е. одинаковые элементы в ходе сортировки меняются местами)
2. Лучшая верменная сложность - Ω(n*log(n))
3. Средняя временная сложность - Θ(n*log(n))
4. Худшая временная сложность - O(n*log(n))
5. Количество применяемой памяти - O(1)

###Timsort
Некоторая информация об алгоритме timsort:
1. Устойчивый алгоритм сортировки
2. Лучшая верменная сложность - Ω(n)
3. Средняя временная сложность - Θ(n log(n))
4. Худшая временная сложность - O(nlog(n))
5. Количество применяемой памяти - O(n)


###Сравнение двух алгоритмов в рамках поставленной задачи

Для начала надо сказать что сортировка подсчетом была бы не самым лучшим решением в рамках конкретной задачи
и на это есть ряд причин:
- Она работает только при целочисленных значениях
- Имеет преимущество перед другими алгоритмами только если размер массива больше чем диапазон значений (k)

На этом фоне если посмотреть на пирамидальную сортировку у нее есть несколько существенных плюсов:
- Во-первых независимость от типов данных внутри массива, если к ним применимы операции сравнения
- Во-вторых если посмотреть на временные сложности можно сделать вывод что в любом случае гарантирована временная сложность
*nlog(n)* - а предсказуемое время вычисления при неизвестных параметрах массива это на мой взгяд огромный плюс.


### Что же на практике?

Временные замеры производились с помощью conda и magic-command timeit

Если задать массив 20 тысяч элементов на вход работа фукнций будет следующей


***counting_sort.py (разброс значений с -50 до 50)***

![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/img/counting_sort20k.PNG "20,000 элементов")


***heap_sort.py (разброс значений с -50 до 50)***

![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/img/heap_sort20k.PNG "20,000 элементов")

***timsort (разброс значений с -50 до 50)***

![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/img/timsort20k.PNG "20,000 элементов")

Как мы видим в данном случае *сортировка подсчетом* выполняется быстрее, но что будет если мы не будем соблюдать условия
что разброс значений будет меньше размера массива? Заодно увеличим количество элементов в массиве до 100,000


***counting_sort.py (разброс значений с -1 миллона до 1 миллиона)***

![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/img/counting_sort100kbigrange.PNG "100,000 элементов")


***heap_sort.py (разброс значений с -1 миллиона до 1 миллиона)***

![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/img/heap_sort100kbigrange.PNG "100,000 элементов")

***timsort (разброс значений с -1 миллиона до 1 миллиона)***

![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/img/timsort100k.PNG "100,000 элементов")


###Итог
Универсального алгоритма сортировки не существует, для каждой задачи хорош свой алгоритм. Даже алгоритм сортировки пузырьком
хорош если нужно отсортировать небольшой массив. Как видно встроенный метод Python sort() реализующий алгоритм timsort отлично справляется.
Но в условиях поставленных задачей я бы выбрал пирамидальный алгоритм сортировки
так как он ведет себя предсказуемо при любых входных данный и как бонус количество применяемой памяти равно О(1).
