#Тестовое задание 3

---
В рамках 3 тестового задания надо было реализовать функцию сортировки которая отсортирует заданный массив быстрее всего.
 При этом массив может быть абсолютно любого размера и как отсортированным так и не отсортированным.

В рамках данного задания мною были реализованны 2 алгоритма сортировки: __*сортировка подсчетом*__ и 
__*пирамидальная сортировка*__.

###Сортировка подсчетом

Исходный код сортировки подсчетом содержится в файле **counting_sort.py**.

Некоторая информация об алгоритме сортировки подсчетом:
1. Устойчевый алгоритм сортировки (т.к. мы по факту пересобираем массив)
2. Лучшая верменная сложность - Ω(n+k), где k - разница между max и min элементом
3. Средняя временная сложность - Θ(n+k), где k - разница между max и min элементом
4. Худшая временная сложность - O(n+k), где k - разница между max и min элементом
5. Количество применяемой памяти - O(k), где k - разница между max и min элементом
6. Сильно зависима от *k* 

###Пирамидальная сортировка

Исходный код сортировки подсчетом содержится в файле **heap_sort.py**

Некоторая информация об алгоритме пирамидальной сортировки:
1. Неустойчивый алгоритм сортировки (т.е. одинаковые элементы в ходе сортировки меняются местами)
2. Лучшая верменная сложность - Ω(n*log(n))
3. Средняя временная сложность - Θ(n*log(n))
4. Худшая временная сложность - O(n*log(n))
5. Количество применяемой памяти - O(1)

###Сравнение двух алгоритмов в рамках поставленной задачи

Для начала надо сказать что сортировка подсчетом была бы не самым лучшим решением в рамках конкретной задачи
и на это есть ряд причин:
- Она работает только при целочисленных значениях
- Имеет преимущество перед другими алгоритмами только если размер массива больше чем диапазон значений (k)

На этом фоне если посмотреть на пирамидальную сортировку у нее есть несколько существенных плюсов:
- Во-первых независимость от типов данных внутри массива, если к ним применимы операции сравнения
- Во-вторых если посмотреть на временные сложности можно сделать вывод что в любом случае гарантирована временная сложность
*nlog(n)* - а предсказуемое время вычисления при неизвестных параметрах массива это на мой взгяд огромный плюс.


### Что же на практике?

Временные замеры производились с помощью conda и magic-command timeit

Если задать массив 20 тысяч элементов на вход работа фукнций будет следующей

#####counting_sort.py (разброс значений с -50 до 50)
![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/counting_sort20k.PNG "20,000 элементов")

#####heap_sort.py (разброс значений с -50 до 50)
![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/heap_sort20k.PNG "20,000 элементов")

Как мы видим в данном случае *сортировка подсчетом* выполняется быстрее, но что будет если мы не будем соблюдать условия
что разброс значений будет меньше размера массива? Заодно увеличим количество элементов в массиве до 100,000

#####counting_sort.py (разброс значений с -1 миллона до 1 миллиона)
![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/counting_sort100kbigrange.PNG "100,000 элементов")

#####heap_sort.py (разброс значений с -1 миллиона до 1 миллиона)
![alt text](https://github.com/WhiteChewy/WargamingTests/blob/master/Test_3/heap_sort100kbigrange.PNG "100,000 элементов")

###Итог
Универсального алгоритма сортировки не существует, для каждой задачи хорош свой алгоритм. Даже алгоритм сортировки пузырьком
хорош если нужно отсортировать небольшой массив. Но в условиях поставленных задачей я бы выбрал пирамидальный алгоритм сортировки
так как он ведет себя предсказуемо при любых входных данный и как бонус количество применяемой памяти равно О(1). 