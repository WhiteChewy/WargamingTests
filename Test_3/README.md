#Тестовое задание 3

---
В рамках 3 тестового задания надо было реализовать функцию сортировки которая отсортирует заданный массив быстрее всего.
 При этом массив может быть абсолютно любого размера и как отсортированным так и не отсортированным.

В рамках данного задания мною были реализованны 2 алгоритма сортировки: __*сортировка подсчетом*__ и 
__*пирамидальная сортировка*__.

###Сортировка подсчетом

Исходный код сортировки подсчетом содержится в файле **counting_sort.py**.

Некоторая информация об алгоритме сортировки подсчетом:
1. Устойчевый алгоритм сортировки (т.к. мы по факту пересобираем массив)
2. Лучшая верменная сложность - Ω(n+k), где k - разница между max и min элементом
3. Средняя временная сложность - Θ(n+k), где k - разница между max и min элементом
4. Худшая временная сложность - O(n+k), где k - разница между max и min элементом
5. Количество применяемой памяти - O(k), где k - разница между max и min элементом
6. Сильно зависима от *k* 

###Пирамидальная сортировка

Исходный код сортировки подсчетом содержится в файле **heap_sort.py**

Некоторая информация об алгоритме пирамидальной сортировки:
1. Неустойчивый алгоритм сортировки (т.е. одинаковые элементы в ходе сортировки меняются местами)
2. Лучшая верменная сложность - Ω(n*log(n))
3. Средняя временная сложность - Θ(n*log(n))
4. Худшая временная сложность - O(n*log(n))
5. Количество применяемой памяти - O(1)

###Сравнение двух алгоритмов в рамках поставленной задачи

Для начала надо сказать что сортировка подсчетом была бы не самым лучшим решением в рамках конкретной задачи
и на это есть ряд причин:
- Она работает только при целочисленных значениях
- Имеет преимущество перед другими алгоритмами только если размер массива больше чем диапазон значений (k)

На этом фоне если посмотреть на пирамидальную сортировку у нее есть несколько существенных плюсов:
- Во-первых независимость от типов данных внутри массива, если к ним применимы операции сравнения
- Во-вторых если посмотреть на временные сложности можно сделать вывод что в любом случае гарантирована временная сложность
*nlog(n)* - а предсказуемое время вычисления при неизвестных параметрах массива это на мой взгяд огромный плюс.


### Что же на практике?

Временные замеры производились с помощью conda и magic-command timeit

Если задать массив 20 тысяч элементов на вход работа фукнций будет следующей

#####counting_sort.py
